{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pytom-match-pick","text":"<p>GPU-accelerated template matching for cryo-electron tomography, originally developed in PyTom, as a standalone Python package that is run from the command line. </p> <p>This software is developed by Marten L. Chaillet (@McHaillet) and Sander Roet (@sroet) in the group of Friedrich F\u00f6rster at Utrecht University.</p> <p></p>"},{"location":"#requires","title":"Requires","text":"<pre><code>miniconda3\nnvidia-cuda-toolkit\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>There are 2 options for creating a conda environment. We recommend option (1) which will later allow cupy to build  against a system installed cuda-toolkit. Compared to option (2) this can give an almost two-fold speedup:</p> <ol> <li> <p>(recommended) Create a new python 3 environment:</p> <pre><code>conda create -n pytom_tm python=3\n</code></pre> </li> <li> <p>Create a new environment with a prebuild cupy version and complete CUDA-toolkit. This is more reliable, but takes more      disk space and has less optimal performance.</p> <pre><code>conda create -n pytom_tm -c conda-forge python=3 cupy cuda-version=11.8\n</code></pre> </li> </ol> <p>Once the environment is created, activate it:</p> <pre><code>conda activate pytom_tm\n</code></pre> <p>Then install the code with <code>pip</code> (building cupy can take a while!):</p> <pre><code>python -m pip install pytom-match-pick[plotting]\n</code></pre> <p>The installation above also adds the optional dependencies <code>[matplotlib, seaborn]</code> which are required to run  <code>pytom_estimate_roc.py</code>. They are not essential to the core template matching functionality, so for some systems  (such as certain cluster environments) it might be desirable to skip them. In that case remove <code>[plotting]</code> from the pip install command:</p> <pre><code>python -m pip install pytom-match-pick\n</code></pre>"},{"location":"#cupy-warning","title":"Cupy warning","text":"<p>Having issues running the software? If cupy is not correctly installed,  <pre><code>python -c \"import pytom_tm\"\n</code></pre></p> <p>can show a cupy warning. If this is the case, this probably means cupy is not correctly installed. Alternatively, cupy can sometimes be installed without issue but not detect CUDA correctly. In that case, the following should raise some errors: <pre><code>python -c \"import cupy as cp; a = cp.zeros((100,100))\"\n</code></pre></p> <p>To solve cupy installation issues, please check  the cupy docs. It might be solved by installing a  specific build compatible with the installed cuda toolkit.   </p>"},{"location":"#usage","title":"Usage","text":"<p>The following scripts are available to run with <code>--help</code> to see parameters:</p> <ul> <li>create a template from an mrc file containing a density map: <code>pytom_create_template.py --help</code></li> <li>create a mask for template matching: <code>pytom_create_mask.py --help</code></li> <li>run template matching with the mask (.mrc) and template (.mrc) on a tomogram (.mrc): <code>pytom_match_template.py --help</code></li> <li>extract candidates from a job file (.json) created in the template matching output folder: <code>pytom_extract_candidate.py --help</code></li> <li>estimate an ROC curve from a job file (.json): <code>pytom_estimate_roc.py --help</code></li> <li>merge multiple star files to a single starfile: <code>pytom_merge_stars.py --help</code></li> </ul> <p>Detailed usage instructions and a tutorial are available on our site.</p>"},{"location":"#usage-questions-ideas-and-solutions-engagement-etc","title":"Usage questions, ideas and solutions, engagement, etc","text":"<p>Please use our github discussions for:  - Asking questions about bottlenecks.  - Share ideas and solutions.  - Engage with other community members about processing strategies.  - etc...</p>"},{"location":"#developer-install","title":"Developer install","text":"<p>If you want the most up-to-date version of the code you can get install it from this repository via:</p> <pre><code>git clone https://github.com/SBC-Utrecht/pytom-match-pick.git\ncd pytom-match-pick\npython -m pip install '.[all]'\n</code></pre> <p>if you don't want the optional plotting dependencies use the following install command instead: <pre><code>python -m pip install '.[dev]'\n</code></pre></p> <p>For development, please also install pre-commit to check and autostyle the code before  you make PRs: </p> <pre><code>pre-commit install\n</code></pre> <p>This uses Ruff to check and format whenever you make commits.</p> <p>If you update anything in the (documentation) <code>docs/</code> folder make sure to test build the website locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"#tests","title":"Tests","text":"<p>With the developer install also comes the ability to run the unittests, from the git repository run:</p> <pre><code>cd tests\npython -m unittest discover\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to the project are very welcome! Feel free to make a pull request or suggest an implementation in the issues. For PR's we will gladly give you feedback on how to integrate the code.</p>"},{"location":"#citation","title":"Citation","text":"<p>Chaillet, M. L., van der Schot, G., Gubins, I., Roet, S., Veltkamp, R. C., &amp; F\u00f6rster, F. (2023). Extensive angular sampling enables the sensitive localization of macromolecules in electron tomograms. International Journal of Molecular Sciences, 24(17), 13375. https://doi.org/10.3390/ijms241713375</p>"},{"location":"Developers/","title":"For developers","text":"<p>Star files written out by pytom-match-pick should be easily integratable with other software as it follows RELION star file conventions. The only difference are three column headers with extraction statistics, which are important to maintain for annotations.</p> <p>The exact header is:</p> <pre><code># Created by the starfile Python package (version x.x.x) at xx:xx:xx on xx/xx/xxxx\n\n\ndata_\n\nloop_\n_rlnCoordinateX #1\n_rlnCoordinateY #2\n_rlnCoordinateZ #3\n_rlnAngleRot #4\n_rlnAngleTilt #5\n_rlnAnglePsi #6\n_rlnLCCmax #7\n_rlnCutOff #8\n_rlnSearchStd #9\n_rlnDetectorPixelSize #10\n_rlnMicrographName #11\n</code></pre> <p>With RELION5 compatibility mode in <code>pytom_extract_candidates.py</code> the star file  columns slightly change. The positions are here relative to the tomogram center  and in Angstrom instead of nr. of voxels:</p> <pre><code># Created by the starfile Python package (version x.x.x) at xx:xx:xx on xx/xx/xxxx\n\n\ndata_\n\nloop_\n_rlnCenteredCoordinateXAngst #1\n_rlnCenteredCoordinateYAngst #2\n_rlnCenteredCoordinateZAngst #3\n_rlnAngleRot #4\n_rlnAngleTilt #5\n_rlnAnglePsi #6\n_rlnLCCmax #7\n_rlnCutOff #8\n_rlnSearchStd #9\n_rlnDetectorPixelSize #10\n_rlnTomoName #11\n</code></pre>"},{"location":"Frequently-asked-questions-%28FAQ%29/","title":"FAQ","text":""},{"location":"Frequently-asked-questions-%28FAQ%29/#how-to-deal-with-gold-beads","title":"How to deal with gold beads?","text":"<p>Gold beads (and other artifacts) can often interfer in template matching due to their high electron scattering potential. The easiest way to deal with them is by removing them on the micrograph level prior to reconstruction. The following IMOD commands can do the trick:</p> <pre><code>imodfindbeads -size [GOLD_BEAD_DIAMETER_IN_PIXELS] -input TS_ID.st -output  TS_ID.fid  -spacing 0.8\nccderaser --input TS_ID.st --output TS_ID_erased.st -model TS_ID.fid -order 0 -circle / -better [1.5 * GOLD_BEAD_RADIUS_IN_PIXELS] -merge 1 -exclude -skip 1 -expand 3\n</code></pre>"},{"location":"Frequently-asked-questions-%28FAQ%29/#what-template-box-size-should-i-use","title":"What template box size should I use?","text":"<p>For the simple missing wedge model a box size that tightly fits the template and mask is easiest (and slightly faster).</p> <p>For the full per-tilt-weighting model its better to have some overhang, a rought estimate could be a box size of <code>4 * particle_diameter</code>. This aids in sampling the CTF function and the individual tilts in Fourier space. However, the mask radius should still snuggly fit the template. Although the larger box size slows down rotations slightly, the search benefits more from better sampling of the weighting function.</p>"},{"location":"Frequently-asked-questions-%28FAQ%29/#is-my-particle-handedness-correct","title":"Is my particle handedness correct?","text":"<p>If template matching is giving unexpectedly poor results for the particle of interest, it might that the template has the wrong handedness. In that case, the <code>pytom_create_template.py</code> has the option <code>--mirror</code> to produce a mirrored version of the template. We advice to create a mirrored and non-mirrored version of the template and to run template matching with both. After extracting ~1000 particle from both jobs, while setting the <code>--cut-off</code> to -1 (in <code>pytom_extract_candidates.py</code>). You can plot the results with the following python code:</p> <pre><code>import starfile\nimport matplotlib.pyplot as plt\n\nraw = starfile.read('[TOMO_ID]_particles.star')\nmirror = starfile.read('[TOMO_ID]_mirror_particles.star')\n\nfig, ax = plt.subplots(figsize=(5,5))\nax.plot(raw['ptmLCCmax'], label='raw')\nax.plot(mirror['ptmLCCmax'], label='mirror')\nax.set_xlabel('Particle index')\nax.set_ylabel('LCCmax')\nax.legend()\nplt.show()\n</code></pre>"},{"location":"Frequently-asked-questions-%28FAQ%29/#what-tomogram-reconstruction-method-should-i-use","title":"What tomogram reconstruction method should I use?","text":"<p>Have a look at this thread on our Discussions page: https://github.com/SBC-Utrecht/pytom-match-pick/discussions/206! Feel free to join in with the disucssion if you have another opinion or questions.</p>"},{"location":"Timings/","title":"Timings","text":"<p>This page provides a quick overview of software timings. All were run on a tomogram with dimension (462x478x250) and a template box size of 34x34x34.</p> <pre><code>Single GPU (GTX 1080 Ti)\n12.85 (deg) - 193 sec. (3.22 min.)\n</code></pre> <pre><code>4 GPU's (GTX 1080 Ti)\n12.85 (deg) - 48 sec. (0.80 min.)\n7.00 (deg) - 306 sec. (5.10 min.)\n3.00 (deg) - 3801 sec. (63.35 min.)\n</code></pre>"},{"location":"Usage/","title":"Usage","text":"<p>Features in a tomogram that resemble a structural 'template' can be localized in an automated fashion using 'template matching'. In this approach a 3D template is correlated with a given tomogram. In this procedure the different possible rotations and translations are sampled exhaustively using the algorithm described in F\u00f6rster et al. (2010).</p>"},{"location":"Usage/#requirements","title":"Requirements","text":"<p>For usage you need at least a set of reconstructed tomograms in the MRC format and a template structure in the MRC format. Tomograms in IMOD format (.rec) are also okay but need to be renamed (or softlinked!) to have the correct extension (.mrc). Tomograms are ideally binned 6x or 8x to prevent excessive runtimes. The template can be an EM reconstruction (from the EMDB) or a PDB that was coverted to a density (for example via Chimera molmap).</p>"},{"location":"Usage/#template-matching-workflow","title":"Template matching workflow","text":"<p>Using template matching in this software consists of the following steps:</p> <ol> <li>Creating a template and mask</li> <li>Matching the template in a tomogram</li> <li>Extracting particles</li> <li>Merging annotations for export to other software</li> </ol>"},{"location":"Usage/#1-creating-a-template-and-mask","title":"1. Creating a template and mask","text":"<p>Keep in mind:</p> <ul> <li>The template and mask need to have the same box size.</li> <li>The template needs to have the same contrast as the tomogram (e.g. the particles    are black in both the tomogram and template). Contrast can be adjusted with the    <code>--invert</code> option.</li> </ul>"},{"location":"Usage/#pytom_create_templatepy","title":"pytom_create_template.py","text":"<p>Using an EM map as a reference structure generally leads to the best results. Alternatively a structure from the PDB can be converted in Chimera(X) using the molmap command to create an MRC file that models the electrostatic potential. A good ballpark for the box size of the template is 2 or 3 times the particle diameter (along its longest axis). </p> <pre><code>usage: pytom_create_template.py [-h] -i INPUT_MAP [-o OUTPUT_FILE]\n                                [--input-voxel-size-angstrom INPUT_VOXEL_SIZE_ANGSTROM]\n                                --output-voxel-size-angstrom\n                                OUTPUT_VOXEL_SIZE_ANGSTROM [--center CENTER]\n                                [--low-pass LOW_PASS] [-b BOX_SIZE]\n                                [--invert INVERT] [-m MIRROR] [--log LOG]\n\nGenerate template from MRC density. -- Marten Chaillet (@McHaillet)\n\noptions:\n  -h, --help            show this help message and exit\n  -i INPUT_MAP, --input-map INPUT_MAP\n                        Map to generate template from; MRC file.\n  -o OUTPUT_FILE, --output-file OUTPUT_FILE\n                        Provide path to write output, needs to end in .mrc .\n                        If not provided file is written to current directory\n                        in the following format:\n                        template_{input_map.stem}_{voxel_size}A.mrc\n  --input-voxel-size-angstrom INPUT_VOXEL_SIZE_ANGSTROM\n                        Voxel size of input map, in Angstrom. If not provided\n                        will be read from MRC input (so make sure it is\n                        annotated correctly!).\n  --output-voxel-size-angstrom OUTPUT_VOXEL_SIZE_ANGSTROM\n                        Output voxel size of the template, in Angstrom. Needs\n                        to be equal to the voxel size of the tomograms for\n                        template matching. Input map will be downsampled to\n                        this spacing.\n  --center CENTER       Set this flag to automatically center the density in\n                        the volume by measuring the center of mass.\n  --low-pass LOW_PASS   Apply a low pass filter to this resolution, in\n                        Angstrom. By default a low pass filter is applied to a\n                        resolution of (2 * output_spacing_angstrom) before\n                        downsampling the input volume.\n  -b BOX_SIZE, --box-size BOX_SIZE\n                        Specify a desired size for the output box of the\n                        template. Only works if it is larger than the\n                        downsampled box size of the input.\n  --invert INVERT       Multiply template by -1. WARNING: not needed if ctf\n                        with defocus is already applied!\n  -m MIRROR, --mirror MIRROR\n                        Mirror the final template before writing to disk.\n  --log LOG             Can be set to `info` or `debug`\n</code></pre>"},{"location":"Usage/#pytom_create_maskpy","title":"pytom_create_mask.py","text":"<p>The mask around the template can be quite tight to remove as much noise as possible around the particles of interest. We recommend around 10%-20% overhang relative to the particle radius. You can also generate an ellipsoidal mask for particles that do not approximate well as a sphere. Though you will probably need to reorient this mask in chimera and resample to the grid of the template. Optionally you could also create a structured mask around the template in external software (via thresholding and dilation for example). Take into account that non-spherical masks roughly double the template matching computation time.</p> <pre><code>usage: pytom_create_mask.py [-h] -b BOX_SIZE [-o OUTPUT_FILE]\n                            [--voxel-size VOXEL_SIZE] -r RADIUS\n                            [--radius-minor1 RADIUS_MINOR1]\n                            [--radius-minor2 RADIUS_MINOR2] [-s SIGMA]\n\nCreate a mask for template matching. -- Marten Chaillet (@McHaillet)\n\noptions:\n  -h, --help            show this help message and exit\n  -b BOX_SIZE, --box-size BOX_SIZE\n                        Shape of square box for the mask.\n  -o OUTPUT_FILE, --output-file OUTPUT_FILE\n                        Provide path to write output, needs to end in .mrc .If\n                        not provided file is written to current directory in\n                        the following format:\n                        ./mask_b[box_size]px_r[radius]px.mrc\n  --voxel-size VOXEL_SIZE\n                        Provide a voxel size to annotate the MRC (currently\n                        not used for any mask calculation).\n  -r RADIUS, --radius RADIUS\n                        Radius of the spherical mask in number of pixels. In\n                        case minor1 and minor2 are provided, this will be the\n                        radius of the ellipsoidal mask along the x-axis.\n  --radius-minor1 RADIUS_MINOR1\n                        Radius of the ellipsoidal mask along the y-axis in\n                        number of pixels.\n  --radius-minor2 RADIUS_MINOR2\n                        Radius of the ellipsoidal mask along the z-axis in\n                        number of pixels.\n  -s SIGMA, --sigma SIGMA\n                        Sigma of gaussian drop-off around the mask edges in\n                        number of pixels. Values in the range from 0.5-1.0 are\n                        usually sufficient for tomograms with 20A-10A voxel\n                        sizes.\n</code></pre>"},{"location":"Usage/#2-matching-the-template-in-a-tomogram","title":"2. Matching the template in a tomogram","text":""},{"location":"Usage/#pytom_match_templatepy","title":"pytom_match_template.py","text":"<p>This script requires at least a tomogram, a template, a mask, the min and max tilt angles (for missing wedge constraint), an angular search, and a GPU index to run. The search can be limited along any dimension with the <code>--search-x</code>, <code>--search-y</code>, and <code>--search-z</code> parameters; for example to skip some empty regions in the z-dimension where the ice layer is not yet present, or to remove some reconstruction artifact region along the x-dimension. With the <code>--volume-split</code> option, a tomogram can be split into chunks to allow them to fit in GPU memory (useful for large tomograms). Providing multiple GPU's will allow the program to split the angular search (or the subvolume search) over multiple cards to speed up the algorithm. </p> <p>The software automatically calculates the angular search based on the available  resolution and provided particle diameter. The required search is found from the  Crowther criterion \\(\\Delta \\alpha = \\frac{180}{\\pi r_{max} d}\\). For the maximal  resolution the voxel size is used, unless a low-pass filter is specified as this  limits the available maximal resolution. You can exploit this to reduce the angular  search! For non-spherical particles we suggest choosing the particle diameter as the  longest axis of the macromolecule. </p> <p>In case the template matching is run with a non-spherical mask, it is essential to set the <code>--non-spherical-mask</code> flag. It requires a slight modification of the calculation that will roughly double the computation time, so only use non-spherical masks if absolutely necessary.</p>"},{"location":"Usage/#optimizing-results-per-tilt-weighting-with-ctfs-and-dose-accumulation","title":"Optimizing results: per tilt weighting with CTFs and dose accumulation","text":"<p>Optimal results are obtained by also incorporating information for the 3D CTF. You  can pass the following files (and parameters):</p> <ul> <li>Tilt angles: a <code>.rawtlt</code> or <code>.tlt</code> file to the <code>--tilt-angles</code> parameter with all the    tilt    angles used to reconstruct the tomogram. You should then also set the    <code>--per-tilt-weighting</code> flag.</li> <li>CTF data: a <code>.defocus</code> file from IMOD or <code>.txt</code> file to <code>--defocus-file</code>. The <code>.   txt</code> file    should specify the defocus of each tilt in \\(\\mu m\\). You can also give a    single defocus value (in \\(\\mu m\\)). The CTF will also require input for    <code>--voltage</code>, <code>--amplitude-contrast</code>, and <code>--spherical-abberation</code>.</li> <li>Dose weighting: a <code>.txt</code> file to <code>--dose-accumulation</code> with the accumulated dose per    tilt (assuming the same ordering as <code>.tlt</code>). Each line contains a single float    specifying the accumulated dose in \\(e^{-}/\\text{\u00c5}^{2}\\). Dose weighting only works in    combination with <code>--per-tilt-weighting</code>.</li> </ul> <p>(As a side note, you can also only enable <code>--per-tilt-weighting</code> without dose accumulation and CTFs, or with either dose accumulation or CTFs.)</p> <p>When enabling the CTF model here (with the defocus file), it is important that the template is not multiplied with a CTF before passing it to this script. The template only needs to be scaled to the correct pixel size and the contrast should be adjusted to match the contrast in the tomograms.</p> <p>Secondly, if the tomogram was CTF corrected, for example by using IMODs  strip-based CTF correction or NovaCTF. Its important to add the parameter  <code>--tomogram-ctf-model phase-flip</code> which modifies the template CTF to match the  tomograms CTF correction.</p>"},{"location":"Usage/#background-corrections","title":"Background corrections","text":"<p>The software contains two background correction methods that might improve results:  <code>--spectral-whitening</code> or <code>--random-phase-correction</code> (from STOPGAP). In our  experience the random phase correction is most reliable, while spectral whitening  never seemed to clearly improve results.</p> <pre><code>usage: pytom_match_template.py [-h] -t TEMPLATE -v TOMOGRAM [-d DESTINATION]\n                               -m MASK\n                               [--non-spherical-mask NON_SPHERICAL_MASK]\n                               [--particle-diameter PARTICLE_DIAMETER]\n                               [--angular-search ANGULAR_SEARCH]\n                               [--z-axis-rotational-symmetry Z_AXIS_ROTATIONAL_SYMMETRY]\n                               [-s VOLUME_SPLIT VOLUME_SPLIT VOLUME_SPLIT]\n                               [--search-x SEARCH_X SEARCH_X]\n                               [--search-y SEARCH_Y SEARCH_Y]\n                               [--search-z SEARCH_Z SEARCH_Z]\n                               [--tomogram-mask TOMOGRAM_MASK]\n                               [-a TILT_ANGLES [TILT_ANGLES ...]]\n                               [--per-tilt-weighting PER_TILT_WEIGHTING]\n                               [--voxel-size-angstrom VOXEL_SIZE_ANGSTROM]\n                               [--low-pass LOW_PASS] [--high-pass HIGH_PASS]\n                               [--dose-accumulation DOSE_ACCUMULATION]\n                               [--defocus DEFOCUS]\n                               [--amplitude-contrast AMPLITUDE_CONTRAST]\n                               [--spherical-aberration SPHERICAL_ABERRATION]\n                               [--voltage VOLTAGE] [--phase-shift PHASE_SHIFT]\n                               [--tomogram-ctf-model {phase-flip}]\n                               [--defocus-handedness {-1,0,1}]\n                               [--spectral-whitening SPECTRAL_WHITENING]\n                               [-r RANDOM_PHASE_CORRECTION]\n                               [--half-precision HALF_PRECISION]\n                               [--rng-seed RNG_SEED]\n                               [--relion5-tomograms-star RELION5_TOMOGRAMS_STAR]\n                               -g GPU_IDS [GPU_IDS ...] [--log LOG]\n\nRun template matching. -- Marten Chaillet (@McHaillet)\n\noptions:\n  -h, --help            show this help message and exit\n\nTemplate, search volume, and output:\n  -t TEMPLATE, --template TEMPLATE\n                        Template; MRC file. Object should match the contrast\n                        of the tomogram: if the tomogram has black ribosomes,\n                        the reference should be black.\n                        (pytom_create_template.py has an option to invert\n                        contrast)\n  -v TOMOGRAM, --tomogram TOMOGRAM\n                        Tomographic volume; MRC file.\n  -d DESTINATION, --destination DESTINATION\n                        Folder to store the files produced by template\n                        matching.\n\nMask:\n  -m MASK, --mask MASK  Mask with same box size as template; MRC file.\n  --non-spherical-mask NON_SPHERICAL_MASK\n                        Flag to set when the mask is not spherical. It adds\n                        the required computations for non-spherical masks and\n                        roughly doubles computation time.\n\nAngular search:\n  --particle-diameter PARTICLE_DIAMETER\n                        Provide a particle diameter (in Angstrom) to\n                        automatically determine the angular sampling using the\n                        Crowther criterion. For the max resolution, (2 * pixel\n                        size) is used unless a low-pass filter is specified,\n                        in which case the low-pass resolution is used. For\n                        non-globular macromolecules choose the diameter along\n                        the longest axis.\n  --angular-search ANGULAR_SEARCH\n                        This option overrides the angular search calculation\n                        from the particle diameter. If given a float it will\n                        generate an angle list with healpix for Z1 and X1 and\n                        linear search for Z2. The provided angle will be used\n                        as the maximum for the linear search and for the mean\n                        angle difference from healpix.Alternatively, a .txt\n                        file can be provided with three Euler angles (in\n                        radians) per line that define the angular search.\n                        Angle format is ZXZ anti-clockwise (see: https://www.c\n                        cpem.ac.uk/user_help/rotation_conventions.php).\n  --z-axis-rotational-symmetry Z_AXIS_ROTATIONAL_SYMMETRY\n                        Integer value indicating the rotational symmetry of\n                        the template around the z-axis. The length of the\n                        rotation search will be shortened through division by\n                        this value. Only works for template symmetry around\n                        the z-axis.\n\nVolume control:\n  -s VOLUME_SPLIT VOLUME_SPLIT VOLUME_SPLIT, --volume-split VOLUME_SPLIT VOLUME_SPLIT VOLUME_SPLIT\n                        Split the volume into smaller parts for the search,\n                        can be relevant if the volume does not fit into GPU\n                        memory. Format is x y z, e.g. --volume-split 1 2 1\n  --search-x SEARCH_X SEARCH_X\n                        Start and end indices of the search along the x-axis,\n                        e.g. --search-x 10 490\n  --search-y SEARCH_Y SEARCH_Y\n                        Start and end indices of the search along the y-axis,\n                        e.g. --search-x 10 490\n  --search-z SEARCH_Z SEARCH_Z\n                        Start and end indices of the search along the z-axis,\n                        e.g. --search-x 30 230\n  --tomogram-mask TOMOGRAM_MASK\n                        Here you can provide a mask for matching with\n                        dimensions (in pixels) equal to the tomogram. If a\n                        subvolume only has values &lt;= 0 for this mask it will\n                        be skipped.\n\nFilter control:\n  -a TILT_ANGLES [TILT_ANGLES ...], --tilt-angles TILT_ANGLES [TILT_ANGLES ...]\n                        Tilt angles of the tilt-series, either the minimum and\n                        maximum values of the tilts (e.g. --tilt-angles -59.1\n                        60.1) or a .rawtlt/.tlt file with all the angles (e.g.\n                        --tilt-angles tomo101.rawtlt). In case all the tilt\n                        angles are provided a more elaborate Fourier space\n                        constraint can be used\n  --per-tilt-weighting PER_TILT_WEIGHTING\n                        Flag to activate per-tilt-weighting, only makes sense\n                        if a file with all tilt angles have been provided. In\n                        case not set, while a tilt angle file is provided, the\n                        minimum and maximum tilt angle are used to create a\n                        binary wedge. The base functionality creates a fanned\n                        wedge where each tilt is weighted by cos(tilt_angle).\n                        If dose accumulation and CTF parameters are provided\n                        these will all be incorporated in the tilt-weighting.\n  --voxel-size-angstrom VOXEL_SIZE_ANGSTROM\n                        Voxel spacing of tomogram/template in angstrom, if not\n                        provided will try to read from the MRC files. Argument\n                        is important for band-pass filtering!\n  --low-pass LOW_PASS   Apply a low-pass filter to the tomogram and template.\n                        Generally desired if the template was already filtered\n                        to a certain resolution. Value is the resolution in A.\n  --high-pass HIGH_PASS\n                        Apply a high-pass filter to the tomogram and template\n                        to reduce correlation with large low frequency\n                        variations. Value is a resolution in A, e.g. 500 could\n                        be appropriate as the CTF is often incorrectly\n                        modelled up to 50nm.\n  --dose-accumulation DOSE_ACCUMULATION\n                        Here you can provide a file that contains the\n                        accumulated dose at each tilt angle, assuming the same\n                        ordering of tilts as the tilt angle file. Format\n                        should be a .txt file with on each line a dose value\n                        in e-/A2.\n  --defocus DEFOCUS     Here you can provide an IMOD defocus (.defocus) file\n                        (version 2 or 3) , a text (.txt) file with a single\n                        defocus value per line (in \u03bcm), or a single defocus\n                        value (in \u03bcm). The value(s), together with the other\n                        ctf parameters (amplitude contrast, voltage, spherical\n                        abberation), will be used to create a 3D CTF weighting\n                        function. IMPORTANT: if you provide this, the input\n                        template should not be modulated with a CTF\n                        beforehand. If it is a reconstruction it should\n                        ideally be Wiener filtered.\n  --amplitude-contrast AMPLITUDE_CONTRAST\n                        Amplitude contrast fraction for CTF.\n  --spherical-aberration SPHERICAL_ABERRATION\n                        Spherical aberration for CTF in mm.\n  --voltage VOLTAGE     Voltage for CTF in keV.\n  --phase-shift PHASE_SHIFT\n                        Phase shift (in degrees) for the CTF to model phase\n                        plates.\n  --tomogram-ctf-model {phase-flip}\n                        Optionally, you can specify if and how the CTF was\n                        corrected during reconstruction of the input tomogram.\n                        This allows match-pick to match the weighting of the\n                        template to the tomogram. Not using this option is\n                        appropriate if the CTF was left uncorrected in the\n                        tomogram. Option 'phase-flip' : appropriate for IMOD's\n                        strip-based phase flipping or reconstructions\n                        generated with novaCTF/3dctf.\n  --defocus-handedness {-1,0,1}\n                        Specify the defocus handedness for defocus gradient\n                        correction of the CTF in each subvolumes. The more\n                        subvolumes in x and z, the finer the defocus gradient\n                        will be corrected, at the cost of increased computing\n                        time. It will only have effect for very clean and\n                        high-resolution data, such as isolated macromolecules.\n                        IMPORTANT: only works in combination with --volume-\n                        split ! A value of 0 means no defocus gradient\n                        correction (default), 1 means correction assuming\n                        correct handedness (as specified in Pyle and Zianetti\n                        (2021)), -1 means the handedness will be inverted. If\n                        uncertain better to leave off as an inverted\n                        correction might hamper results.\n  --spectral-whitening SPECTRAL_WHITENING\n                        Calculate a whitening filtering from the power\n                        spectrum of the tomogram; apply it to the tomogram\n                        patch and template. Effectively puts more weight on\n                        high resolution features and sharpens the correlation\n                        peaks.\n\nAdditional options:\n  -r RANDOM_PHASE_CORRECTION, --random-phase-correction RANDOM_PHASE_CORRECTION\n                        Run template matching simultaneously with a phase\n                        randomized version of the template, and subtract this\n                        'noise' map from the final score map. For this method\n                        please see STOPGAP as a reference:\n                        https://doi.org/10.1107/S205979832400295X .\n  --half-precision HALF_PRECISION\n                        Return and save all output in float16 instead of the\n                        default float32\n  --rng-seed RNG_SEED   Specify a seed for the random number generator used\n                        for phase randomization for consistent results!\n  --relion5-tomograms-star RELION5_TOMOGRAMS_STAR\n                        Here, you can provide a path to a RELION5\n                        tomograms.star file (for example from a tomogram\n                        reconstruction job). pytom-match-pick will fetch all\n                        the tilt-series metadata from this file and overwrite\n                        all other metadata options.\n\nDevice control:\n  -g GPU_IDS [GPU_IDS ...], --gpu-ids GPU_IDS [GPU_IDS ...]\n                        GPU indices to run the program on.\n\nLogging/debugging:\n  --log LOG             Can be set to `info` or `debug`\n</code></pre>"},{"location":"Usage/#3-extracting-particles","title":"3. Extracting particles","text":"<p>Both scripts run on the job file created in <code>pytom_match_template.py</code> which contains details about correlation statistics and the output files. The job file always has the format <code>[TOMO_ID]_job.json</code>.</p> <p>IMPORTANT For both scripts the <code>[-r, --radius-px]</code> option needs to be considered carefully. The particle extraction will mask out spheres with this radius around each peak in the score volume and prevents selecting the same macromolecule twice. It is specified as an integer number of pixels (not Angstrom!) and ideally it should be the radius of the particle of interest. It can be found by dividing the particle radius by the pixel size, e.g. a ribosome (r = 290\u00c5 / 2) in a 15\u00c5 tomogram should gets a pixel radius of 9.6. As it needs to be an integer value and ribosomes are not perfect spheres, it is best to round it down to 9 pixels. </p>"},{"location":"Usage/#pytom_extract_candidatespy","title":"pytom_extract_candidates.py","text":""},{"location":"Usage/#star-file-metadata","title":"STAR file metadata","text":"<p>Resulting STAR files from extraction have three colums with extraction statistics (<code>LCCmax</code>, <code>CutOff</code>, <code>SearchStd</code>). Dividing the <code>LCCmax</code> and the <code>CutOff</code> by the <code>SearchStd</code>, will express them as a number of \\(\\sigma\\) or (3D SNR; similar to Rickgauer et al. (2017).</p> <p>STAR files written out by the template matching module will have RELION compliant column headers, i.e. <code>rlnCoordinateX</code> and <code>rlnAgleRot</code>, to simplify integration with other software. The Euler angles that are written out therefore also follow the same conventions as RELION and Warp, i.e. <code>rlnAngleRot</code>, <code>rlnAngleTilt</code>, <code>rlnAnglePsi</code> are intrinsic clockwise ZYZ Euler angles. Hence they can be directly used for subtomogram averaging in RELION. See here for more info: https://www.ccpem.ac.uk/user_help/rotation_conventions.php.</p> <p>Please see the For developers section for more details on the  metadata. </p>"},{"location":"Usage/#default-true-positive-estimation","title":"Default true positive estimation","text":"<p>The particle extraction has been updated to use the formula in Rickgauer et al. (2017) for finding the extraction threshold based on the false alarm rate. This was not yet described in our IJMS publication but is essentially very similar to the Gaussian fit that we used. However, it is more reliable and also specific to the standard deviation \\(\\sigma\\) of the search in each tomogram. <code>pytom_match_template.py</code> keeps track of \\(\\sigma\\) and stores it in the job file. The user can specify a number of false positives to allow per tomogram with a minimum value of 1. It can be increased to make the extraction threshold more lenient which might increase the number of true positives at the expense of more false positives. The parameter should roughly correspond to the number of false positives that end up in the extracted particle list.</p> <p>Template matching has a huge search space \\(N_{voxels} * N_{rotations}\\) which is mainly  false positives, and has in comparison a tiny fraction of true positives. If we have  a Gaussian for the background (with expected mean 0 and some standard deviation),  the false alarm rate can be calculated for a certain cut-off value, as it is  dependent on the size of the search space. For example, a false alarm rate of \\((N_ {voxels} * N_{rotations})^{-1}\\), indicates it would expect 1 false positive in the  whole search. This can be calculated with the error function,</p> \\[N^{-1} = \\text{erfc}( \\theta / ( \\sigma \\sqrt{2} ) ) / (2 n_{\\text{FP}})\\] <p>, where theta is the cut-off, sigma the standard deviation of the Gaussian, and N the search space. \\(n_{\\text{FP}}\\) represents the scaling by the user of tolerated number of false positives.</p>"},{"location":"Usage/#tophat-transform-filter","title":"Tophat transform filter","text":"<p>This option can be used to filter the score map for sharp peaks (steep local maxima)  which usually correspond to true positives. This will be described in a forthcoming  publication. For now, you can check out Marten's poster at CCPEM that shows some  preliminary results: 10.5281/zenodo.13165643.</p> <pre><code>usage: pytom_extract_candidates.py [-h] -j JOB_FILE\n                                   [--tomogram-mask TOMOGRAM_MASK]\n                                   [--ignore_tomogram_mask IGNORE_TOMOGRAM_MASK]\n                                   -n NUMBER_OF_PARTICLES\n                                   [--number-of-false-positives NUMBER_OF_FALSE_POSITIVES]\n                                   -r RADIUS_PX [-c CUT_OFF]\n                                   [--tophat-filter TOPHAT_FILTER]\n                                   [--tophat-connectivity TOPHAT_CONNECTIVITY]\n                                   [--relion5-compat RELION5_COMPAT]\n                                   [--log LOG] [--tophat-bins TOPHAT_BINS]\n                                   [--plot-bins PLOT_BINS]\n\nRun candidate extraction. -- Marten Chaillet (@McHaillet)\n\noptions:\n  -h, --help            show this help message and exit\n  -j JOB_FILE, --job-file JOB_FILE\n                        JSON file that contain all data on the template\n                        matching job, written out by pytom_match_template.py\n                        in the destination path.\n  --tomogram-mask TOMOGRAM_MASK\n                        Here you can provide a mask for the extraction with\n                        dimensions (in pixels) equal to the tomogram. All\n                        values in the mask that are smaller or equal to 0 will\n                        be removed, all values larger than 0 are considered\n                        regions of interest. It can be used to extract\n                        annotations only within a specific cellular region. If\n                        the job was run with a tomogram mask, this file will\n                        be used instead of the job mask\n  --ignore_tomogram_mask IGNORE_TOMOGRAM_MASK\n                        Flag to ignore the input and TM job tomogram mask.\n                        Useful if the scores mrc looks reasonable, but this\n                        finds 0 particles to extract\n  -n NUMBER_OF_PARTICLES, --number-of-particles NUMBER_OF_PARTICLES\n                        Maximum number of particles to extract from tomogram.\n  --number-of-false-positives NUMBER_OF_FALSE_POSITIVES\n                        Number of false positives to determine the false alarm\n                        rate. Here one can increase the recall of the particle\n                        of interest at the expense of more false positives.\n                        The default value of 1 is recommended for particles\n                        that can be distinguished well from the background\n                        (high specificity). The value can also be set between\n                        0 and 1 to make the cut-off more restrictive.\n  -r RADIUS_PX, --radius-px RADIUS_PX\n                        Particle radius in pixels in the tomogram. It is used\n                        during extraction to remove areas around peaks\n                        preventing double extraction.\n  -c CUT_OFF, --cut-off CUT_OFF\n                        Override automated extraction cutoff estimation and\n                        instead extract the number-of-particles down to this\n                        LCCmax value. Setting to 0 will keep extracting until\n                        number-of-particles, or until there are no positive\n                        values left in the score map. Values larger than 1\n                        make no sense as the correlation cannot be higher than\n                        1.\n  --tophat-filter TOPHAT_FILTER\n                        Attempt to filter only sharp correlation peaks with a\n                        tophat transform\n  --tophat-connectivity TOPHAT_CONNECTIVITY\n                        Set kernel connectivity for ndimage binary structure\n                        used for the tophat transform. Integer value in range\n                        1-3. 1 is the most restrictive, 3 the least\n                        restrictive. Generally recommended to leave at 1.\n  --relion5-compat RELION5_COMPAT\n                        Write out centered coordinates in Angstrom for\n                        RELION5.\n  --log LOG             Can be set to `info` or `debug`\n  --tophat-bins TOPHAT_BINS\n                        Number of bins to use in the histogram of occurences\n                        in the tophat transform code (for both the estimation\n                        and the plotting).\n  --plot-bins PLOT_BINS\n                        Number of bins to use for the occurences vs LCC_max\n                        plot.\n</code></pre>"},{"location":"Usage/#pytom_estimate_rocpy","title":"pytom_estimate_roc.py","text":"<p>This script runs the Gaussian fit as described in the IJMS publication. It requires installation with plotting dependencies as it writes out or displays a figure showing the Gaussian fit and estimated ROC curve. The benefit is that it estimates some classification statistics (such as false discovery rate and sensitivity). You can use it to esimate an extraction threshold for a representative tomogram and then supply this threshold as the <code>[-c, --cut-off]</code> parameter for <code>pytom_extract_candidates.py</code>.</p> <pre><code>usage: pytom_estimate_roc.py [-h] -j JOB_FILE -n NUMBER_OF_PARTICLES -r\n                             RADIUS_PX [--bins BINS]\n                             [--gaussian-peak GAUSSIAN_PEAK]\n                             [--force-peak FORCE_PEAK] [--crop-plot CROP_PLOT]\n                             [--show-plot SHOW_PLOT] [--log LOG]\n                             [--ignore_tomogram_mask IGNORE_TOMOGRAM_MASK]\n\nEstimate ROC curve from TMJob file. -- Marten Chaillet (@McHaillet)\n\noptions:\n  -h, --help            show this help message and exit\n  -j JOB_FILE, --job-file JOB_FILE\n                        JSON file that contain all data on the template\n                        matching job, written out by pytom_match_template.py\n                        in the destination path.\n  -n NUMBER_OF_PARTICLES, --number-of-particles NUMBER_OF_PARTICLES\n                        The number of particles to extract and estimate the\n                        ROC on, recommended is to multiply the expected number\n                        of particles by 3.\n  -r RADIUS_PX, --radius-px RADIUS_PX\n                        Particle radius in pixels in the tomogram. It is used\n                        during extraction to remove areas around peaks\n                        preventing double extraction.\n  --bins BINS           Number of bins for the histogram to fit Gaussians on.\n  --gaussian-peak GAUSSIAN_PEAK\n                        Expected index of the histogram peak of the Gaussian\n                        fitted to the particle population.\n  --force-peak FORCE_PEAK\n                        Force the particle peak to the provided peak index.\n  --crop-plot CROP_PLOT\n                        Flag to crop the plot relative to the height of the\n                        particle population.\n  --show-plot SHOW_PLOT\n                        Flag to use a pop-up window for the plot instead of\n                        writing it to the location of the job file.\n  --log LOG             Can be set to `info` or `debug`\n  --ignore_tomogram_mask IGNORE_TOMOGRAM_MASK\n                        Flag to ignore the TM job tomogram mask. Useful if the\n                        scores mrc looks reasonable, but this finds 0\n                        particles\n</code></pre>"},{"location":"Usage/#4-merging-annotations-for-export-to-other-software","title":"4. Merging annotations for export to other software","text":"<p>After running template matching and candidate extraction on multiple tomograms, each tomogram will have an individual starfile with particle annotations. Each starfile will contain the <code>MicrographName</code> column which refers back to the tomogram name. Multiple starfiles can therefore be appended to results in a large list which can be used in other software (such as RELION, WarpM) to load annotations. These software will link the annotations to specific tilt-series using the <code>MicrographName</code> column.</p>"},{"location":"Usage/#pytom_merge_starspy","title":"pytom_merge_stars.py","text":"<p>Without providing any parameters the script will try to merge all the starfiles in the current working directory and save them to a new file <code>particles.star</code>.</p> <pre><code>usage: pytom_merge_stars.py [-h] [-i INPUT_DIR] [-o OUTPUT_FILE] [--log LOG]\n\nMerge multiple star files in the same directory. -- Marten Chaillet\n(@McHaillet)\n\noptions:\n  -h, --help            show this help message and exit\n  -i INPUT_DIR, --input-dir INPUT_DIR\n                        Directory with star files, script will try to merge\n                        all files that end in '.star'.\n  -o OUTPUT_FILE, --output-file OUTPUT_FILE\n                        Output star file name.\n  --log LOG             Can be set to `info` or `debug`\n</code></pre>"},{"location":"benchmarks/defocus_handedness/","title":"Measuring defocus handedness in EMPIAR-10985","text":"<p>By Marten Chaillet (@McHaillet), August 2024. If you  found these  results useful, please cite our zenodo repository:  10.5281/zenodo.10728422.</p> <p>Although it has been shown multiple times that correcting defocus gradients is very  important for subtomogram averaging in tilt-series data, the effects on particle  localization have not been clearly illustrated (to my knowledge). The software Warp  introduced a detailed correction of defocus gradients during template matching by  splitting the tomogram into many small sub-boxes where the template can be corrected  by tilt-dependent defocus offsets  that adhere to the sample geometry. For an untilted image these  offsets are a function of the z-coordinate in the tomogram, while for tilted image the  defocus gradient is a function of both the x- and z-coordinate in the tomogram  (assuming the  tilt-axis is aligned with the y-axis). The defocus gradient are therefore expected  to be the strongest for the images collected a high sample tilts. Considering that the  resolution in tomograms is generally not considered to be high due to alignment errors  and that the high tilt angles usually have an additional drop-off in resolution due to  beam damage, I wondered how much effect defocus gradient correction actually has  on the template matching scores. To test this in this benchmark, I here try to measure  the defocus  handedness of a tomogram.</p>"},{"location":"benchmarks/defocus_handedness/#approach","title":"Approach","text":"Initial view of the data: annotations (turqoise sphere) made by  pytom-match-pick on tomogram 27 of EMPIAR-10985. <p>To properly measure the defocus handedness, I selected a dataset of isolated  ribosomes in thin ice collected at a pixel size of 1.07 \u00c5  (EMPIAR-10985; see figure above). Isolated macromolecules provide the highest  resolution (contrary to in situ data). I used an approach, similar  to Warp,  that calculates the defocus offsets in each subvolume of a tomogram. To measure the  effects of correcting for defocus gradients, I  ran template matching assuming both a default and inverted defocus handedness of the  tilt-series. This inverted handedness comes down to  inverting the tilt angles during  calculation of the defocus offsets. Either one of these two handedness' should be  correct and hopefully influence the results sufficiently to see a difference. </p> <p>The defocus offsets are calculated as</p> <pre><code>z_offset = z_coordinate * cos(tilt_angle) + x_coordinate * sin(tilt_angle) \n</code></pre> <p>where <code>z_coordinate</code> and <code>x_coordinate</code> are the center of the subvolume relative to  the center of the tomogram. A similar calculation could be applied for calculating  the defocus offsets of a subtomogram centered on a particle in the dataset. The  <code>z_offset</code> is then scaled to the correct units (\u03bcm).  </p> <p>I do not apply phase flipping to the tilt series prior (or during) reconstruction,  instead I modulate the template with oscillating CTF's that should match the CTF's  of each tilt image.</p> <p>The resolution of sampling defocus offsets is in this dataset primarily defined by the  number of subvolumes along the x-axis of the tomogram. As the ice layer is very thin, there will not be much variation along the z-axis. Therefore, I chose here to sample  3 subvolumes along the x-axis. More subvolumes should improve the model of the  defocus gradient, however, I assumed that this would be sufficient to measure a  difference  between regular and inverted defocus handedness. </p>"},{"location":"benchmarks/defocus_handedness/#results","title":"Results","text":"<p>To assess the effects of the defocus handedness on the template matching scores, I  analyzed the results as a function of the x-coordinate (see figure below). As the  scores are normalized by the standard deviation (\u03c3) during the full template matching  search, it is of note that on average they are ~20 times \u03c3. </p> <p>Looking at the expected false alarm rate compared to the background, gives a better sense of the background separation. With a  tomogram of size 510x720x74 and 248,400 rotations (angular increment of 3.9\u00b0), the  full search space is 6,749,723,520,000. Calculating the \u03c3 cut-off of the background  for a false alarm rate of 1 with the inverse complementary error function, </p> <pre><code>erfcinv(2 / search_space) * sqrt(2)\n</code></pre> <p>results in a cut-off of 7.30 \u03c3. This indicates the ribosomes correlate well  above the expected background noise, likely owing to the thin ice layer with isolated  macromolecules.</p> LCC<sub>max</sub> scores (normalized by the standard deviation from  template matching) plotted as a function  of the x-coordinate. In blue the results are shown that assumes the default defocus  handedness, while orange shows the results of inverted defocus handedness. The left  figure shows a scatter plot, while the right shows fitted quadratic functions to  both sets of points. The gray areas indicate the 95% confidence interval of the fit.    <p>Looking at the effects of the defocus handedness, the scatter plot (left side  of figure) seems to display a very minor effect of the defocus handedness on the  normalized  LCC<sub>max</sub> scores (download or open in new tab to zoom in). Around the center  of the tomogram (x=0) the scattered points seems to overlap, which should be the  case as the central subvolume does not have defocus offsets. Only on the left and  right side of the plot, there appears a tiny increase in LCC<sub>max</sub> scores  for the inverted defocus handedness. To better assess the effect, I fitted a quadratic  function to both sets of  LCC<sub>max</sub> scores as a function of the x-coordinate (right side of figure).  This visualization makes it more easily discernible that there is an increase in  LCC<sub>max</sub> values on both the left and right side for the inverted defocus  handedness. (It is of note, that I had to adjust the y-axis limits on the right side  to visualize this effect.) It appears the inverted defocus handedness is correct for  this tilt-series. </p> <p>Small side note: The inverted handedness seems to be the correct one. However, if the  tilt-axis angle  were set to 180 for AreTomo, the template would not need to be mirrored  and (probably) neither the defocus handedness. I decided not to rerun  this analysis with that setting as the point was to discern the effect of  regular/inverted defocus handedness on the scores.</p>"},{"location":"benchmarks/defocus_handedness/#conclusion","title":"Conclusion","text":"<p>Overall, the effects of defocus gradient correction seem minor. I attempted to  measure the effect of defocus gradient correction by applying both a regular and  inverted defocus handedness to subvolumes of tomograms during template matching. The  tomogram used here has very high contrast due to a thin ice layer and isolated  ribosomes. The images were additionally recorded at a pixel size of 1.07 \u00c5. Template  matching was performed at a voxel size of 8.56 \u00c5, providing a maximal resolution of  1/(17.12) \u00c5<sup>-1</sup> in the tomogram which is generally considered a small pixel  size for tomograms. As the effects of defocus handedness in this dataset  were already difficult to discern, I expect the contribution of defocus gradient  correction during template matching for in situ datasets to be  negligible.</p>"},{"location":"benchmarks/defocus_handedness/#how-to-reproduce","title":"How-to-reproduce","text":""},{"location":"benchmarks/defocus_handedness/#requirements","title":"Requirements","text":"<ul> <li>AreTomo 1.3 </li> <li>IMOD 4.11.24</li> <li>pytom-match-pick 0.7.2 (and should work with higher versions)</li> </ul>"},{"location":"benchmarks/defocus_handedness/#implementation-of-defocus-gradient","title":"Implementation of defocus gradient","text":"<p>An implementation for the defocus gradient calculation is available in our  repository in <code>src/pytom_tm/TMJob.py</code>, see function  <code>get_defocus_offsets()</code>. </p>"},{"location":"benchmarks/defocus_handedness/#tilt-series-preprocessing","title":"Tilt series preprocessing","text":"<p>Download tilt-series 27 from EMPIAR-10985:</p> <ul> <li>9x9_ts_27_sort.mrc</li> <li>9x9_ts_27_sort.mrc.mdoc</li> <li>9x9_ts_27_sort_dose.txt</li> </ul> <p>I put the data in the following directory structure:</p> <pre><code>empiar-10985/\n+- raw_data/\n\u00a6  +- 9x9_ts_27_sort.mrc\n\u00a6  +- 9x9_ts_27_sort.mrc.mdoc\n\u00a6  +- 9x9_ts_27_sort_dose.txt\n+- templates/\n+- metadata/\n+- tomogram/\n+- tm_init/\n+- tm_patch_def_reg/\n+- tm_patch_def_inv/\n</code></pre> <p>Create a file with accumulated dose and a rawtlt file:</p> <pre><code>grep '^TiltAngle' raw_data/9x9_ts_27_sort.mrc.mdoc | awk -F'=' '{print $2}' &gt; metadata/9x9_ts_27_sort.rawtlt\n</code></pre> <pre><code>awk '{print $1}' raw_data/9x9_ts_27_sort_dose.txt &gt; metadata/9x9_ts_27_sort_accumulated_dose.txt\n</code></pre> <p>Use AreTomo (1.3) to align and reconstruct the tilt-series. The .mdoc file does not specify a tilt-axis angle, so I let AreTomo find it.</p> <pre><code>aretomo -InMrc raw_data/9x9_ts_27_sort.mrc -OutMrc tomogram/9x9_ts_27.mrc -AngFile metadata/9x9_ts_27_sort.rawtlt -AlignZ 400 -VolZ 600 -OutBin 8  -Gpu 0  -Wbp 1 -FlipVol 1\n</code></pre> <p>Fit ctf with IMOD; in the GUI select <code>fit each view separately</code> and then <code>autofit all  views</code>. Tilt-axis angle is set to '-3.2323' as optimized by AreTomo (check the .aln file).</p> <pre><code>ctfplotter -input raw_data/9x9_ts_27_sort.mrc -angleFn metadata/9x9_ts_27_sort.rawtlt -aAngle -3.2323 -defFn metadata/9x9_ts_27_sort.defocus -pixelSize 0.107 -volt 300 -cs 2.7  -expDef 3000 -range -60,60\n</code></pre>"},{"location":"benchmarks/defocus_handedness/#creating-a-template-and-mask","title":"Creating a template and mask","text":"<p>I downloaded the subtomogram average EMD-33115 calculated for the EMPIAR dataset. NOTE: The reference is mirrored as I noticed in the first run without mirroring that the scores were unexpectedly poor. Mirroring fixes this issue.</p> <pre><code>pytom_create_template.py -i templates/emd_33115.map -o templates/70S.mrc --output-voxel 8.56 -b 60 --invert --mirror\n</code></pre> <pre><code>pytom_create_mask.py -b 60 -o templates/mask.mrc --voxel-size 8.56 -r 14 -s 1\n</code></pre>"},{"location":"benchmarks/defocus_handedness/#running-template-matching","title":"Running template matching","text":"<p>(Optional) Run a simple job with low-pass to confirm if localization is working. Low-pass filtering reduces available resolution and therefore the angular search.</p> <pre><code>pytom_match_template.py -t templates/70S.mrc -m templates/mask.mrc -v tomogram/9x9_ts_27.mrc -d tm_init --particle-diameter 250 -a metadata/9x9_ts_27_sort.rawtlt --per-tilt-weighting --voxel-size 8.56 --dose metadata/9x9_ts_27_sort_accumulated_dose.txt --defocus metadata/9x9_ts_27_sort.defocus  --amplitude 0.07 --spherical 2.7 --voltage 300 -g 0 --log debug --low-pass 30\n</code></pre> <pre><code>pytom_extract_candidates.py -j tm_init/9x9_ts_27_job.json -n 1000 -r 5 --cut-off 0.4\n</code></pre> <p>Run with default defocus handedness and a full rotation search. NOTE: defocus  handedness is calculated for subvolumes so  the <code>-s</code> option needs to be used to split the tomogram into multiple subvolumes. Only the splits along the x-axis influence the defocus values in this case as that is perpendicular to the tilt axis.</p> <pre><code>pytom_match_template.py -t templates/70S.mrc -m templates/mask.mrc -v tomogram/9x9_ts_27.mrc -d tm_patch_def_reg --particle-diameter 250 -a metadata/9x9_ts_27_sort.rawtlt --per-tilt-weighting --voxel-size 8.56 --dose metadata/9x9_ts_27_sort_accumulated_dose.txt --defocus metadata/9x9_ts_27_sort.defocus  --amplitude 0.07 --spherical 2.7 --voltage 300 -g 0 -s 3 1 1 --defocus-handedness 1\n</code></pre> <pre><code>pytom_extract_candidates.py -j tm_patch_def_reg/9x9_ts_27_job.json -n 1000 -r 5 --cut-off 0.3\n</code></pre> <p>Run with inverted defocus handedness.</p> <pre><code>pytom_match_template.py -t templates/70S.mrc -m templates/mask.mrc -v tomogram/9x9_ts_27.mrc -d tm_patch_def_inv --particle-diameter 250 -a metadata/9x9_ts_27_sort.rawtlt --per-tilt-weighting --voxel-size 8.56 --dose metadata/9x9_ts_27_sort_accumulated_dose.txt --defocus metadata/9x9_ts_27_sort.defocus  --amplitude 0.07 --spherical 2.7 --voltage 300 -g 0 -s 3 1 1 --defocus-handedness -1\n</code></pre> <pre><code>pytom_extract_candidates.py -j tm_patch_def_inv/9x9_ts_27_job.json -n 1000 -r 5 --cut-off 0.3\n</code></pre>"},{"location":"benchmarks/defocus_handedness/#plotting-the-results","title":"Plotting the results","text":"<p>Our repository contains the file docs/benchmarks/defocus_gradient_analysis.ipynb that contains the exact code to  reproduce the plots shown here. In brief:</p> <ul> <li>The notebook reads the starfiles containing the regular and inverted defocus    handedness template matching annotations.</li> <li>A check is made that the set of coordinates overlaps between the two jobs is the same.</li> <li>The results are plotted as x-coordinate versus the score (after normalizing by the    standard deviation).</li> <li>A quadratic curve is fit to both these sets of points to better visualize any    changes between them.</li> </ul>"},{"location":"benchmarks/defocus_handedness/#optional-visualization-with-blik","title":"(Optional) Visualization (with Blik)","text":"<p>Using Blik version 0.9.</p> <pre><code>napari -w blik -- tm_patch_def_inv/9x9_ts_27_particles.star tomogram/9x9_ts_27.mrc\n</code></pre> <p>Then do the following steps:</p> <ul> <li>Set the <code>Slice thickness A</code> on the right to 40</li> <li>From the <code>Experiment</code> dropdown menu on the right select the tomogram</li> <li>Click in the center</li> <li>Then do <code>Ctrl + Y</code> to toggle 3D view</li> <li>Select the points layer (ends with <code>- particle positions</code>)</li> <li>In layer controls select the icon <code>Select points</code> </li> <li>Do <code>Ctrl + A</code> and then set the <code>Point size</code> to 10</li> <li>Click in the center (not on a point) to deselect the points</li> <li>Press <code>Ctrl + Y</code> again to switch back to 2D view</li> </ul> <p>Now you can scroll through the z-axis of the tomogram and the template matching  annotations with the slider on the bottom.</p>"},{"location":"tutorials/Tutorial/","title":"Ribosomes on ER microsomes","text":"<p>In this tutorial we are going to use template matching to detect human 80S ribosomes in a sample of ER-derived microsomes. As the tutorial dataset imaged isolated ER-derived vesicles with a 200 keV microscope, and the ice layer thickness is on the order of ~180 nm, the contrast is quite good. So, to make it more challenging, we are also going to test matching with only the 60S subunit. This way we can demonstrate some optimizations that can be made to maximize correlation. Besides, using baited reconstruction can also be a good way to prevent bias in the template search. </p>"},{"location":"tutorials/Tutorial/#preparing-the-dataset-and-template","title":"Preparing the dataset and template","text":"<p>The tutorial dataset can be downloaded from DataverseNL: https://doi.org/10.34894/TLGJCM. The raw tilt-series can also be found on DataverseNL: https://doi.org/10.34894/OLYEFI. Tilt-series were collected identically to EMPIAR-11751. A quick overview of the preprocessing workflow: (1) MotionCor2 was used to correct the motion in raw movie frames, (2) ctfplotter from IMOD was used to estimate defocus values, (3) ctfphaseflip from IMOD was used to do strip-based phaseflipping, and (4) AreTomo was used for reconstructing tomograms (weighted-back-projection) with 5x5 local patch alignment. Besides the tomograms (in MRC format), we provide for each tomogram a <code>.rawtlt</code> file with tilt angles, a <code>_dose.txt</code> file with accumulated dose per frame, and a <code>.defocus</code> file with per tilt defocus values.</p> <p>We will initially use a cryo-EM reconstruction of the human 80S ribosome, which you will need to download from the EMDB: https://www.emdataresource.org/EMD-2938.</p> <p>Secondly, we will use a PDB model of the human 80S ribosome, 6qzp. To prepare the structure, first download the <code>.cif</code> file from the PDB. Then, the structure can be opened in ChimeraX and with the following command in the ChimeraX command line, a simple electrostatic potential model of the 60S large ribosomal subunit can be generated: </p> <p><code>molmap #1/L? 5 gridSpacing 1.724</code>.</p> <p>This means we sample the map on a 1.724 \u00c5 grid (which corresponds to the tilt-series' pixel size of this dataset) and at a resolution of 5 \u00c5. <code>#1/L?</code> selects only chains starting with L from loaded model 1, i.e. chains that belong to the large subunit. Afterwards save the generated potential as an .mrc file: <code>6qzp_60S.mrc</code>. (It can also be downloaded here)</p> <p>Finally, we assume the following folder structure for this tutorial, with the current working directory <code>tm_tutorial</code> :</p> <pre><code>tm_tutorial/\n+- dataset/\n\u00a6  +- tomo200528_100.mrc\n\u00a6  +- tomo200528_100.rawtlt\n\u00a6  +- tomo200528_100.defocus\n\u00a6  +- tomo200528_100_dose.txt\n\u00a6  +- tomo200528_101.mrc\n\u00a6  +- ...\n+- templates/\n\u00a6  +- 6qzp_60S.mrc\n\u00a6  +- emd_2938.map\n+- results_80S/\n+- results_60S/\n</code></pre>"},{"location":"tutorials/Tutorial/#tomogram-voxel-size-fix","title":"Tomogram voxel size fix","text":"<p>I made the mistake to not annotate the voxel size in the tomograms correctly (thanks to @jinxsfe for pointing this out!). Please run the following command to fix the voxel size in the MRC headers:</p> <pre><code>for x in dataset/.mrc; do python -c \"import mrcfile; mrc = mrcfile.mmap('$x', 'r+'); mrc.voxel_size = 13.79\"; done\n</code></pre>"},{"location":"tutorials/Tutorial/#part-1-matching-the-80s-ribosome-with-a-binary-wedge-and-simple-ctf","title":"Part 1: Matching the 80S ribosome with a binary wedge and simple CTF","text":"<p>This section corresponds to the base method where the template is prepared by convolution with a single CTF and is adjusted with a binary wedge during the template matching run.</p>"},{"location":"tutorials/Tutorial/#preparing-the-template-and-mask","title":"Preparing the template and mask","text":"<p>Let's generate a template for the template matching run:</p> <pre><code>pytom_create_template.py \\\n -i templates/emd_2938.map \\\n -o templates/80S.mrc \\\n --input-voxel 1.1 \\\n --output-voxel 13.79 \\\n --center \\\n --invert \\\n -b 60\n</code></pre> <p>The <code>--ctf-correction</code> option convolutes the template with a single 3D-CTF with the specified defocus to roughly match the appearance of the particles in the tomograms. Even though each tilt-series will have different defocus values, for full ribosomes this is usually sufficient. The <code>--flip-phase</code> option takes the <code>absolute()</code> of the CTF before applying it. This is because the tomograms have been CTF-corrected which is done through phase-flipping. Since the <code>absolute()</code> operation makes all the values positive and our input map is white, we get back a white template. However, the tomograms of the dataset have black contrast (veryify by opening a tomogram), so finally the <code>--invert</code> flag needs to be set to make the template black.</p> <p>Secondly, we need a mask with the same box size as the template and a radius that fully encompasses our ribosome structure. The diameter of a ribosome is roughly 300 \u00c5, which means we need at least (300 \u00c5 / 13.79 \u00c5 =) 22 pixels to cover the ribosome. With some overhang we extend it to 24 pixels diameter, and therefore set the mask radius (<code>--radius</code>) to 12 pixels. The mask will also need a smooth fall-off to prevent aliasing artifacts, which we set with <code>--sigma</code>:</p> <pre><code>pytom_create_mask.py \\\n -b 60 \\\n -o templates/mask.mrc \\\n --voxel-size 13.79 \\\n --radius 12 \\\n --sigma 1\n</code></pre> <p>The <code>--voxel-size</code> is not really required for the mask, but in case you want to open the mask and template in ChimeraX (or napari) they are automatically scaled to the right size. If you have ChimeraX/napari/3dmod available its anyway a good idea to open the mask and template at this point to get a feel for the data. The mask should always be 1 in the center and 0 outside with a smooth fall-off. The template should have contrast matching your tomogram (i.e. black if the tomogram has black objects, and white vice versa).</p> Template and mask slice <p>The large template and mask box sizes might seem surprising, but they are needed for proper weighting during template matching. Similar to large box size during downstream high-resolution averaging, the overhang here also provides better sampling of weighting functions in Fourier space. The larger size increases the number of sampling points for CTFs and tomographic point spread functions.</p>"},{"location":"tutorials/Tutorial/#running-template-matching","title":"Running template matching","text":"<p>The template matching for the 80S ribosome can be started as follows:</p> <pre><code>pytom_match_template.py \\\n -t templates/80S.mrc \\\n -m templates/mask.mrc \\\n -v dataset/tomo200528_100.mrc \\\n -d results_80S/ \\\n --particle-diameter 300 \\\n -a dataset/tomo200528_100.rawtlt \\\n --low-pass 40 \\\n --defocus 3 \\\n --amplitude 0.08 \\\n --spherical 2.7 \\\n --voltage 200 \\\n --tomogram-ctf-model phase-flip \\\n -g 0\n</code></pre> <p>A low-pass filter of 40 \u00c5 is set to prevent bias. Then, the angular search is calculated from the Crowther criterion using a diameter \\(d\\) of 300 \u00c5 and a \\(r_{max}\\) of 1/(40 \u00c5) (due to the low-pass filter), which results in a roughly 7\u00b0 increment. Here, the program was started on the system GPU with index 0. If you have more GPU's available for the tutorial you can simply add them and pytom-match-pick will automatically distribute the angular search, e.g. <code>-g 0 1 2 3</code> will run on the first 4 GPU's in the system.</p> <p>Out of memory! Although unlikely to happen during the tutorial, in later usage of the software your GPUs might run out of memory. This is especially likely for 4x or lower binned tomograms. If this happens, you can use the <code>--split</code> option to tile the tomogram into multiple sections. You need to specify the number of splits along each dimension, for example <code>--split 2 1 1</code> will split into 2 sections along the x-axis, <code>--split 2 2 1</code> will split once in x and once in y, resulting in 4 subvolumes!</p> <p>To visualize the results it can be very informative to open the tomogram and score map side-by-side in Napari. Which should look like this:</p> Slice 69 of dataset/tomo200528_100.mrc and results_80S/tomo200528_100_scores.mrc (in Napari) <p>Then we calculate the receiver operator curve (ROC) to estimate true positives using:</p> <pre><code>pytom_estimate_roc.py \\\n -j results_80S/tomo200528_100_job.json \\\n -n 800 \\\n -r 8 \\\n --bins 16 \\\n --crop-plot  &gt; results_80S/tomo200528_100_roc.log\n</code></pre> <p>This will automatically write a file to the folder where the job file is located (<code>tomo200528_100_roc.svg</code>). Additionally, here the terminal output is also written to the file <code>results_80S/tomo200528_100_roc.log</code> as it contains some info on the estimated number of particles in the sample. Catting the log file in the terminal (<code>cat results_80S/tomo200528_100_roc.log</code>), the estimated number of total true positives is approx. 180 ribosomes.</p> ROC curve (results_80S/tomo200528_100_roc.svg) <p>In this case the result is quite good: the Rectangle Under the Curve (RUC) is around 0.9 (1 is optimal). Also the fit of the gaussians seems very appropriate for the histogram, so we can use the estimated cut-off value (<code>0.194</code>) to extract particle coordinates and rotations into a STAR file: </p> <pre><code>pytom_extract_candidates.py -j results_80S/tomo200528_100_job.json -n 300 -r 8 -c 0.194\n</code></pre> <p>This will extract ~160 particles and save their annotations to the file <code>results_80S/tomo200528_100_particles.star</code>.</p> <p>Alternatively, <code>pytom_extract_candidates.py</code> also has a default extraction cut-off estimation that can work well. Run the command without the <code>-c</code> parameter:</p> <pre><code>pytom_extract_candidates.py -j results_80S/tomo200528_100_job.json -n 300 -r 8\n</code></pre> <p>It produces a very similar result: the script prints the estimated cut-off to the terminal (<code>0.197</code>) (very similar to the ROC estimated cut-off) and it also extracts ~160 particles. (Take care: the previous STAR file is overwritten.)</p>"},{"location":"tutorials/Tutorial/#part-2-matching-the-60s-ribosomal-subunit-with-a-tilt-weighted-psf","title":"Part 2: Matching the 60S ribosomal subunit with a tilt-weighted PSF","text":"<p>Now, let's apply the same base method using only the 60S subunit.</p>"},{"location":"tutorials/Tutorial/#preparing-the-template-and-mask_1","title":"Preparing the template and mask","text":"<p>The 60S template can be generated with this command:</p> <pre><code>pytom_create_template.py \\\n -i templates/6qzp_60S.mrc \\\n -o templates/60S.mrc \\\n --input-voxel 1.724 \\\n --output-voxel 13.79 \\\n --center \\\n --invert \\\n -b 60\n</code></pre> <p>For the mask the radius is slightly reduced to constrain it around the 60S subunit:</p> <pre><code>pytom_create_mask.py \\\n -b 60 \\\n -o templates/mask_60S.mrc \\\n --voxel-size 13.79 \\\n --radius 10 \\\n --sigma 1\n</code></pre>"},{"location":"tutorials/Tutorial/#running-template-matching_1","title":"Running template matching","text":"<p>Template matching is run for the 60S subunit, where the low-pass filter is now set  to 35 \u00c5 to include more high-resolution information in the template matching. This  results in an angular sampling ~6.5\u00b0. We  could also entirely remove it, but this would increase the sampling to 5.3\u00b0 which is less feasible for the tutorial. This potentially introduces more bias,  however: with only the large subunit as a reference we can always test for detection  of the small subunit in subtomogram averages.</p> <p>The tilt-weighted PSF is also used here with the flag <code>--per-tilt-weighting</code> and by  providing an IMOD-style defocus file (.defocus) and a text file dose accumulation.  Furthermore, we run with <code>--random-phase-correction</code> to flatten the background noise  using the method introduced by STOPGAP.</p> <pre><code>pytom_match_template.py \\\n -t templates/60S.mrc \\\n -m templates/mask_60S.mrc \\\n -v dataset/tomo200528_100.mrc \\\n -d results_60S/ \\\n --particle-diameter 300 \\\n -a dataset/tomo200528_100.rawtlt \\\n --per-tilt-weighting \\\n --low-pass 35 \\\n --defocus dataset/tomo200528_100.defocus \\\n --amplitude 0.08 \\\n --spherical 2.7 \\\n --voltage 200 \\\n --tomogram-ctf-model phase-flip \\\n --dose-accumulation dataset/tomo200528_100_dose.txt \\\n --random-phase \\\n -g 0\n</code></pre> <p>Again, the slice and score map can be visualized in Napari:</p> Slice 69 of dataset/tomo200528_100.mrc and results_60S/tomo200528_100_scores.mrc (in Napari) <p>Matching only with the 60S subunit greatly reduces the peak height at the actual ribosome locations. Instead gold markers now start correlating heavily with the template and get higher values than the particles of interest. The reason is two-fold: (1) the size of the template has become smaller and (2) the switch from an EM-map to a PDB based model usually reduces correlation. The second point (2) can be caused by the electrostatic potential modelling with the simplistic molmap, which does not consider atom number and solvent embedding, but also because EM-maps might contain some additional heterogeneous densities.</p> <p>The ROC curve is now estimated with: </p> <pre><code>pytom_estimate_roc.py \\\n -j results_60S/tomo200528_100_job.json \\\n -n 800 \\\n -r 8 \\\n --bins 16 \\\n --crop-plot  &gt; results_60S/tomo200528_100_roc.log\n</code></pre> ROC curve (results_60S/tomo200528_100_roc.svg) <p>The loss of quality is mainly visible from the gaussian fit (left plot). Even though the reported quality is still quite good (RUC), it is clear that the curve fit is not proper. This is due to the three mixed distributions that now appear: the left-most correctly fitted background noise (blue curve), the middle peak is from 60S subunits and the right-most peak from gold markers. The particle of interest and gold markers are both fitted as true positives (orange curve).</p> <p>Sadly, gold markers (but also carbon film, and ice) can quite often interfere with  template matching because of their high scattering potential leading to edges with very high signal-to-noise ratio (SNR). One way of dealing with this, is gold marker removal for which their are tools in IMOD, and also deep-learning based tools (e.g. fidder), that remove gold markers on the tilt-image level before tomographic reconstruction. </p>"},{"location":"tutorials/Tutorial/#increasing-the-angular-sampling","title":"Increasing the angular sampling","text":"<p>To improve the results, the angular sampling needs to be increased. For  part 2 of this tutorial, we set the low-pass filter to 35 \u00c5. This means template  matching is now including resolution up to 1/(35 \u00c5),  which changes the required angular sampling to 6.5\u00b0. Running the template matching  command from part 2 without a low-pass filter increases the angular increment to 5.3\u00b0. This roughly doubles the runtime. For me, it takes 1h20m on one RTX3060. </p>"},{"location":"tutorials/Tutorial/#conclusion","title":"Conclusion","text":"<p>We hope you enjoyed our tutorial on GPU-acculated template matching in  cryo-ET! If you ran into any issues during the tutorial please let us know on our github issues page. On this repository's Discussions page you can also reach out with specific questions about running the software for your dataset, and find previous discussions.</p>"}]}